/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * Search Agent API
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  HTTPValidationError,
  RenameThreadRequest,
  RenameThreadResponse,
  SearchRequest,
  SearchResponse,
  ThreadListResponse,
  ThreadResponse
} from '.././model';





/**
 * Health check endpoint.
 * @summary Health Check
 */
export const healthCheckGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.get(
      `/`,options
    );
  }




export const getHealthCheckGetQueryKey = () => {
    return [
    `/`
    ] as const;
    }

    
export const getHealthCheckGetQueryOptions = <TData = Awaited<ReturnType<typeof healthCheckGet>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckGet>>> = ({ signal }) => healthCheckGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheckGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheckGet>>>
export type HealthCheckGetQueryError = AxiosError<unknown>


export function useHealthCheckGet<TData = Awaited<ReturnType<typeof healthCheckGet>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckGet<TData = Awaited<ReturnType<typeof healthCheckGet>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckGet<TData = Awaited<ReturnType<typeof healthCheckGet>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health Check
 */

export function useHealthCheckGet<TData = Awaited<ReturnType<typeof healthCheckGet>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthCheckGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get list of threads with their IDs and titles.
 * @summary Api Get Threads
 */
export const apiGetThreadsApiThreadsGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ThreadListResponse>> => {
    
    
    return axios.get(
      `/api/threads`,options
    );
  }




export const getApiGetThreadsApiThreadsGetQueryKey = () => {
    return [
    `/api/threads`
    ] as const;
    }

    
export const getApiGetThreadsApiThreadsGetQueryOptions = <TData = Awaited<ReturnType<typeof apiGetThreadsApiThreadsGet>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiGetThreadsApiThreadsGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiGetThreadsApiThreadsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiGetThreadsApiThreadsGet>>> = ({ signal }) => apiGetThreadsApiThreadsGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiGetThreadsApiThreadsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiGetThreadsApiThreadsGetQueryResult = NonNullable<Awaited<ReturnType<typeof apiGetThreadsApiThreadsGet>>>
export type ApiGetThreadsApiThreadsGetQueryError = AxiosError<unknown>


export function useApiGetThreadsApiThreadsGet<TData = Awaited<ReturnType<typeof apiGetThreadsApiThreadsGet>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiGetThreadsApiThreadsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiGetThreadsApiThreadsGet>>,
          TError,
          Awaited<ReturnType<typeof apiGetThreadsApiThreadsGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiGetThreadsApiThreadsGet<TData = Awaited<ReturnType<typeof apiGetThreadsApiThreadsGet>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiGetThreadsApiThreadsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiGetThreadsApiThreadsGet>>,
          TError,
          Awaited<ReturnType<typeof apiGetThreadsApiThreadsGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiGetThreadsApiThreadsGet<TData = Awaited<ReturnType<typeof apiGetThreadsApiThreadsGet>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiGetThreadsApiThreadsGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Api Get Threads
 */

export function useApiGetThreadsApiThreadsGet<TData = Awaited<ReturnType<typeof apiGetThreadsApiThreadsGet>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiGetThreadsApiThreadsGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiGetThreadsApiThreadsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all messages for a specific thread.
 * @summary Api Get Thread
 */
export const apiGetThreadApiThreadThreadIdGet = (
    threadId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ThreadResponse>> => {
    
    
    return axios.get(
      `/api/thread/${threadId}`,options
    );
  }




export const getApiGetThreadApiThreadThreadIdGetQueryKey = (threadId?: string,) => {
    return [
    `/api/thread/${threadId}`
    ] as const;
    }

    
export const getApiGetThreadApiThreadThreadIdGetQueryOptions = <TData = Awaited<ReturnType<typeof apiGetThreadApiThreadThreadIdGet>>, TError = AxiosError<HTTPValidationError>>(threadId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiGetThreadApiThreadThreadIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiGetThreadApiThreadThreadIdGetQueryKey(threadId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiGetThreadApiThreadThreadIdGet>>> = ({ signal }) => apiGetThreadApiThreadThreadIdGet(threadId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(threadId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiGetThreadApiThreadThreadIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiGetThreadApiThreadThreadIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof apiGetThreadApiThreadThreadIdGet>>>
export type ApiGetThreadApiThreadThreadIdGetQueryError = AxiosError<HTTPValidationError>


export function useApiGetThreadApiThreadThreadIdGet<TData = Awaited<ReturnType<typeof apiGetThreadApiThreadThreadIdGet>>, TError = AxiosError<HTTPValidationError>>(
 threadId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiGetThreadApiThreadThreadIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiGetThreadApiThreadThreadIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiGetThreadApiThreadThreadIdGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiGetThreadApiThreadThreadIdGet<TData = Awaited<ReturnType<typeof apiGetThreadApiThreadThreadIdGet>>, TError = AxiosError<HTTPValidationError>>(
 threadId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiGetThreadApiThreadThreadIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiGetThreadApiThreadThreadIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiGetThreadApiThreadThreadIdGet>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiGetThreadApiThreadThreadIdGet<TData = Awaited<ReturnType<typeof apiGetThreadApiThreadThreadIdGet>>, TError = AxiosError<HTTPValidationError>>(
 threadId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiGetThreadApiThreadThreadIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Api Get Thread
 */

export function useApiGetThreadApiThreadThreadIdGet<TData = Awaited<ReturnType<typeof apiGetThreadApiThreadThreadIdGet>>, TError = AxiosError<HTTPValidationError>>(
 threadId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiGetThreadApiThreadThreadIdGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiGetThreadApiThreadThreadIdGetQueryOptions(threadId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Rename a thread.
 * @summary Api Rename Thread
 */
export const apiRenameThreadApiThreadThreadIdPut = (
    threadId: string,
    renameThreadRequest: RenameThreadRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RenameThreadResponse>> => {
    
    
    return axios.put(
      `/api/thread/${threadId}`,
      renameThreadRequest,options
    );
  }



export const getApiRenameThreadApiThreadThreadIdPutMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRenameThreadApiThreadThreadIdPut>>, TError,{threadId: string;data: RenameThreadRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof apiRenameThreadApiThreadThreadIdPut>>, TError,{threadId: string;data: RenameThreadRequest}, TContext> => {

const mutationKey = ['apiRenameThreadApiThreadThreadIdPut'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRenameThreadApiThreadThreadIdPut>>, {threadId: string;data: RenameThreadRequest}> = (props) => {
          const {threadId,data} = props ?? {};

          return  apiRenameThreadApiThreadThreadIdPut(threadId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiRenameThreadApiThreadThreadIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof apiRenameThreadApiThreadThreadIdPut>>>
    export type ApiRenameThreadApiThreadThreadIdPutMutationBody = RenameThreadRequest
    export type ApiRenameThreadApiThreadThreadIdPutMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Api Rename Thread
 */
export const useApiRenameThreadApiThreadThreadIdPut = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiRenameThreadApiThreadThreadIdPut>>, TError,{threadId: string;data: RenameThreadRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiRenameThreadApiThreadThreadIdPut>>,
        TError,
        {threadId: string;data: RenameThreadRequest},
        TContext
      > => {

      const mutationOptions = getApiRenameThreadApiThreadThreadIdPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete a thread.
 * @summary Api Delete Thread
 */
export const apiDeleteThreadApiThreadThreadIdDelete = (
    threadId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RenameThreadResponse>> => {
    
    
    return axios.delete(
      `/api/thread/${threadId}`,options
    );
  }



export const getApiDeleteThreadApiThreadThreadIdDeleteMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDeleteThreadApiThreadThreadIdDelete>>, TError,{threadId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof apiDeleteThreadApiThreadThreadIdDelete>>, TError,{threadId: string}, TContext> => {

const mutationKey = ['apiDeleteThreadApiThreadThreadIdDelete'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiDeleteThreadApiThreadThreadIdDelete>>, {threadId: string}> = (props) => {
          const {threadId} = props ?? {};

          return  apiDeleteThreadApiThreadThreadIdDelete(threadId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiDeleteThreadApiThreadThreadIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof apiDeleteThreadApiThreadThreadIdDelete>>>
    
    export type ApiDeleteThreadApiThreadThreadIdDeleteMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Api Delete Thread
 */
export const useApiDeleteThreadApiThreadThreadIdDelete = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDeleteThreadApiThreadThreadIdDelete>>, TError,{threadId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiDeleteThreadApiThreadThreadIdDelete>>,
        TError,
        {threadId: string},
        TContext
      > => {

      const mutationOptions = getApiDeleteThreadApiThreadThreadIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Search API endpoint.
 * @summary Api Search
 */
export const apiSearchApiSearchPost = (
    searchRequest: SearchRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SearchResponse>> => {
    
    
    return axios.post(
      `/api/search`,
      searchRequest,options
    );
  }



export const getApiSearchApiSearchPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiSearchApiSearchPost>>, TError,{data: SearchRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof apiSearchApiSearchPost>>, TError,{data: SearchRequest}, TContext> => {

const mutationKey = ['apiSearchApiSearchPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiSearchApiSearchPost>>, {data: SearchRequest}> = (props) => {
          const {data} = props ?? {};

          return  apiSearchApiSearchPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiSearchApiSearchPostMutationResult = NonNullable<Awaited<ReturnType<typeof apiSearchApiSearchPost>>>
    export type ApiSearchApiSearchPostMutationBody = SearchRequest
    export type ApiSearchApiSearchPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Api Search
 */
export const useApiSearchApiSearchPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiSearchApiSearchPost>>, TError,{data: SearchRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiSearchApiSearchPost>>,
        TError,
        {data: SearchRequest},
        TContext
      > => {

      const mutationOptions = getApiSearchApiSearchPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Chat API endpoint compatible with Vercel AI SDK Data Stream Protocol.

This endpoint streams responses in Vercel AI SDK format for use with useChat hook.
 * @summary Api Chat
 */
export const apiChatApiChatPost = (
    searchRequest: SearchRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.post(
      `/api/chat`,
      searchRequest,options
    );
  }



export const getApiChatApiChatPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiChatApiChatPost>>, TError,{data: SearchRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof apiChatApiChatPost>>, TError,{data: SearchRequest}, TContext> => {

const mutationKey = ['apiChatApiChatPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiChatApiChatPost>>, {data: SearchRequest}> = (props) => {
          const {data} = props ?? {};

          return  apiChatApiChatPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiChatApiChatPostMutationResult = NonNullable<Awaited<ReturnType<typeof apiChatApiChatPost>>>
    export type ApiChatApiChatPostMutationBody = SearchRequest
    export type ApiChatApiChatPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Api Chat
 */
export const useApiChatApiChatPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiChatApiChatPost>>, TError,{data: SearchRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof apiChatApiChatPost>>,
        TError,
        {data: SearchRequest},
        TContext
      > => {

      const mutationOptions = getApiChatApiChatPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    